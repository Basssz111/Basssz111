<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <title>Glass Fix – MeshPhysicalMaterial transmission (r128)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>html,body{height:100%;margin:0} canvas{display:block}</style>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
</head>
<body>
<script>
  const scene = new THREE.Scene();
  // ฉากสีอ่อน + มองทะลุเห็น "พื้น" ด้านหลังวัตถุได้
  scene.background = new THREE.Color(0x000000);

  const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 100);
  camera.position.set(0, 1.2, 3);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(innerWidth, innerHeight);
  renderer.outputEncoding = THREE.sRGBEncoding;
  renderer.shadowMap.enabled = true;
  renderer.physicallyCorrectLights = true;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;
  document.body.appendChild(renderer.domElement);

  new THREE.OrbitControls(camera, renderer.domElement);

  // แสง
  scene.add(new THREE.HemisphereLight(0xffffff, 0x333333, 0.6));
  const dir = new THREE.DirectionalLight(0xffffff, 3.0);
  dir.position.set(3, 5, 2);
  dir.castShadow = true;
  scene.add(dir);

  // พื้น (ให้เห็นฉากหลังจริง ๆ ผ่านกระจก)
  const ground = new THREE.Mesh(
    new THREE.PlaneBufferGeometry(10, 10),
    new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.9, metalness: 0.0 })
  );
  ground.rotation.x = -Math.PI/2;
  ground.receiveShadow = true;
  scene.add(ground);

  // envMap ช่วยเพิ่มความสมจริงของการสะท้อน/หักเห
  const envMap = new THREE.CubeTextureLoader().load([
    'https://threejs.org/examples/textures/cube/Bridge2/posx.jpg',
    'https://threejs.org/examples/textures/cube/Bridge2/negx.jpg',
    'https://threejs.org/examples/textures/cube/Bridge2/posy.jpg',
    'https://threejs.org/examples/textures/cube/Bridge2/negy.jpg',
    'https://threejs.org/examples/textures/cube/Bridge2/posz.jpg',
    'https://threejs.org/examples/textures/cube/Bridge2/negz.jpg'
  ]);
  envMap.encoding = THREE.sRGBEncoding;
  scene.environment = envMap;

  function loadHDRI(path, scene) {
    const rgbeLoader = new THREE.RGBELoader();
    rgbeLoader.setDataType(THREE.UnsignedByteType);
    rgbeLoader.load(path, function(texture) {
        texture.mapping = THREE.EquirectangularReflectionMapping;
        scene.background = texture;
        scene.environment = texture;
    });
}

function loadGLB(path, scene, position = [0,0,0], scale = [1,1,1]) {
    const gltfLoader = new THREE.GLTFLoader();
    gltfLoader.load(path, function(gltf) {
        const model = gltf.scene;
        model.position.set(...position);
        model.scale.set(...scale);
        model.traverse(function(child) {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }
        });
        scene.add(model);
    }, undefined, function(error) {
        console.error('Error loading GLB:', error);
    });
}
loadHDRI('castle.hdr', scene);
loadGLB('castle_on_hills.glb', scene, [-1,0,0], [1,1,1]);

  addEventListener('resize', ()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  // UI for adjusting directional light
  const ui = document.createElement('div');
  ui.style.position = 'fixed';
  ui.style.top = '10px';
  ui.style.left = '10px';
  ui.style.background = 'rgba(255,255,255,0.8)';
  ui.style.padding = '10px';
  ui.style.borderRadius = '8px';
  ui.style.zIndex = 10;
  ui.innerHTML = `
    <label>X: <input id="lx" type="range" min="-10" max="10" step="0.1" value="3"></label><br>
    <label>Y: <input id="ly" type="range" min="0" max="10" step="0.1" value="5"></label><br>
    <label>Z: <input id="lz" type="range" min="-10" max="10" step="0.1" value="2"></label><br>
    <label>Intensity: <input id="lint" type="range" min="0" max="10" step="0.01" value="3"></label>
  `;
  document.body.appendChild(ui);

  function updateLight() {
    dir.position.x = parseFloat(document.getElementById('lx').value);
    dir.position.y = parseFloat(document.getElementById('ly').value);
    dir.position.z = parseFloat(document.getElementById('lz').value);
    dir.intensity = parseFloat(document.getElementById('lint').value);
  }
  document.getElementById('lx').addEventListener('input', updateLight);
  document.getElementById('ly').addEventListener('input', updateLight);
  document.getElementById('lz').addEventListener('input', updateLight);
  document.getElementById('lint').addEventListener('input', updateLight);
  updateLight();

  (function loop(){
    renderer.render(scene, camera);
    requestAnimationFrame(loop);
  })();
</script>
</body>
</html>
